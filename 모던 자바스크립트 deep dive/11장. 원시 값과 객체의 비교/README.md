# 11장 원시 값과 객체의 비교
## 11.0 원시 타입과 객체 타입의 차이점
- 자바스크립트의 데이터 타입 <br/><br/>
![](https://velog.velcdn.com/images/chtoqur/post/568c6bc6-127f-48e7-9927-92717647d3fd/image.png)

> 자바스크립트의 7가지 데이터 타입은 크게 1. 원시 타입과 2. 객체 타입으로 나뉜다. 다음은 두 타입이 가지는 세 가지 차이점이다.<br/>
1. 원시 타입의 값은 변경 불가능 ↔ 객체 타입의 값은 변경 가능한 값
2. 원시 값을 변수에 할당하면 변수(메모리 공간)에는 실제 값이 저장됨 ↔ 객체를 변수에 할당하면 변수(메모리 공간)에는 참조 값이 저장됨
3. 원시 값을 갖는 변수를 다른 변수에 할당 시 원본의 원시 값이 복사되어 전달됨 (=값에 의한 전달) ↔ 객체를 가리키는 변수를 다른 변수에 할당 시 원본의 참조 값이 복사되어 전달됨 (=참조에 의한 전달)

---

## 11.1 원시 값
### 11.1.1 변경 불가능한 값
> 원시 타입의 값 = 원시 값 = 변경 불가능한 값 = 한번 생성되면 읽기 전용으로 변경 불가능 <br/><br/>
이 때, 변수와 값을 구분해서 생각해야 함! 변경 불가능한 것은 값에 대한 진술임. 변수는 언제든지 재할당을 통해 변수 값을 갈음할 수 있다. <br/><br/>
var score = 80; <br/><br/>
즉, 다음과 같은 식에서 score라는 변수는 재할당을 통해 변수 값을 갈아 끼울 수 있지만, 80이라는 원시 타입의 값은 변경이 불가능하다. <br/><br/>
또한 상수와 변경 불가능한 값 또한 다른 개념이다. 상수는 단 한 번만 할당이 허용되어 재할당이 금지된 것이기 때문에 변경 불가능한 값과는 다른 개념이다. <br/><br/>
원시 값을 할당한 변수에 새로운 원시 값을 재할당하면 원시 값을 변경하는 것이 아니라 새로운 메모리 공간을 확보하고, 재할당한 원시 값을 저장한 이후, 변수는 새롭게 재할당한 원시 값을 가리킨다. 변수가 참조하던 메모리 공간의 주소가 바뀌는 것이다. <br/><br/>
이처럼 원시 값을 할당하여 재할당 이외에 변수 값을 변경할 수 있는 방법이 없는 값의 특성을 **불변성**이라 부른다.  

```JS

	var score;
	score = 80;
	score = 90;

```
![](https://velog.velcdn.com/images/chtoqur/post/05221ed8-6ea6-4117-82e0-83814e12e388/image.png)

### 11.1.2 문자열과 불변성
> JS는 자바와 다르게 원시 타입의 문자열 타입을 제공한다. 

```
const str = 'Hello';
const newStr = str;

console.log(str);     // Hello
console.log(newStr);  // Hello

str = 'Bye';          // 원시 값 = 변경 불가능 = 새로운 메모리 공간에 할당
console.log(newStr);  // Hello >> 따라서 newStr의 값 바뀌지 않음

const obj = {
  p : 100
};
const newObj = obj;

console.log(obj);     // {p: 100}
console.log(newObj);  // {p: 100}

obj.p = 200;                                       
console.log(newObj);  // {p: 200} >> 객체 타입의 값 = 변경 가능
```

> cf. 문자열은 '유사 배열 객체'
문자열은 원시 값이지만 원시 값을 객체처럼 사용하면 원시 값을 감싸는 래퍼 객체로 자동 변환된다. 이에 대해서는 21.3절에서 자세히 살펴보자.

![](https://velog.velcdn.com/images/chtoqur/post/0703bfd9-cc09-4561-96b1-d7d0ce7a4477/image.png)


### 11.1.3 값에 의한 전달
> 변수에 원시 값을 할당할 경우 할당받는 변수에는 원시 값이 복사되어 전달된다. 이를 값에 의한 전달이라 한다.

![](https://velog.velcdn.com/images/chtoqur/post/a51bb438-de4c-4d0f-ac67-98dd5985b10d/image.png)
> 변수(copy)에 변수(score)를 할당했을 때
80은 원시 값이므로
1. 새로운 숫자 값 80 생성
2. copy 변수에 할당

---

## 11.2 객체
### 11.2.0 자바스크립트의 객체
> 자바스크립트의 객체는 동적으로 프로퍼티의 개수나 값이 변경될 수 있기 때문에 메모리 공간의 크기를 사전에 정해둘 수 없다. <br/><br/>
자바스크립트에서는 클래스 없이 객체를 생성할 수 있고, 객체가 생성된 이후에도 동적으로 프로퍼티와 메서드를 추가할 수 있다. 자바와 같은 객체지향 언어는 사전에 정의된 클래스를 기반으로 객체를 생성한다는 점이 자바스크립트와 차이를 가진다. <br/><br/>
이러한 JS의 특징은 사용자 입장에서는 편리성을 높여주기도 하지만 동시에 성능적인 측면을 저하시키는 '동적 조회'를 필요로 하게 된다. 자바스크립트는 프로퍼티를 찾기 위해서 오프셋을 이용한다. 이 때, 오프셋이란 객체 내부에서 프로퍼티의 상대적 위치를 나타내는 일종의 (상대적) 주소 값이다. 하지만 객체의 프로퍼티가 언제든 변경될 수 있기 때문에, 없던 프로퍼티가 추가되거나 프로퍼티의 순서가 바뀌게 되면 이 오프셋을 처음부터 다시 찾아내어야 하기 때문에 효율성이 저하된다. 따라서 V8 엔진은 동적 탐색 대신 히든 클래스 방식을 사용해 프로퍼티에 접근하는 성능을 보장한다.

![](https://velog.velcdn.com/images/chtoqur/post/012315bd-aa9d-450d-aebf-d97464c01f8f/image.png)

![](https://velog.velcdn.com/images/chtoqur/post/c7e089cc-c74e-4f1a-9f16-106331b100cd/image.png)

![](https://velog.velcdn.com/images/chtoqur/post/13c8324c-cd43-4d29-b797-e4619672d7f2/image.png)

![](https://velog.velcdn.com/images/chtoqur/post/d808a148-a61d-49a5-9af2-1c3b77be3eb6/image.png)


### 11.2.1 변경 가능한 값 
> 이전에 살펴본 원시 값은 원시 값을 할당한 변수를 통해 메모리 공간에 접근하면 원시 값에 직접 접근할 수 있다. <br/>
반대로 객체를 할당한 변수에는 메모리 공간의 주소가 저장되어 있다. 이를 '참조 값'이라고 한다. 이 참조 값을 통해 실제 객체에 접근할 수 있다. <br/>
이러한 구조에 따라 여러 개의 식별자가 하나의 객체를 공유할 수 있다는 단점이 존재한다. 따라서 a, b, c 식별자가 하나의 객체를 공유할 때 b 식별자가 객체의 프로퍼티를 수정할 경우, 원본 객체의 프로퍼티가 수정되는 것이기 때문에 a와 c가 해당 프로퍼티를 출력할 때 변경된 값으로 출력된다.

### cf. 자바스크립트에서의 얕은 복사와 깊은 복사
> #### I. 복사 기준에 따른 분류
![](https://velog.velcdn.com/images/chtoqur/post/d160bd6f-46db-44d6-bfb3-f299a6890250/image.png)
- 얕은 복사 : 객체에 중첩되어 있는 객체의 경우 참조 값을 복사
- 깊은 복사 : 객체에 중첩되어 있는 객체까지 모두 복사 <br/>
> #### II. 할당 대상에 따른 분류
- 얕은 복사 : 객체를 할당한 변수를 다른 변수에 할당하는 것
- 깊은 복사 : 원시 값을 할당한 변수를 다른 변수에 할당하는 것

### 11.2.2 참조에 의한 전달
![](https://velog.velcdn.com/images/chtoqur/post/17e70f94-9f83-4a3d-9e8f-7613599294be/image.png)
