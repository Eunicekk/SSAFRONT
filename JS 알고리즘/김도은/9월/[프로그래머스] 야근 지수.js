function solution(n, works) {
    
    //n시간 내에 다 처리할 수 있을 때...
    if (works.reduce((a, b) => a + b, 0) <= n) {
        return 0;
    }

    works.sort((a, b) => b - a);

    while (n > 0) {
        if (works[0] > 0) {
            works[0]--;
            n--;
        }

        // 첫 번째 작업량이 그 다음으로 큰 작업량보다 작아졌다면, 위치를 재조정
        // 이 부분은 sort를 매번 호출할 때마다 시간초과가 나기 때문에 '힙 구조'를 js에서 구현해야 함
        let i = 0;
        
        while (i < works.length - 1 && works[i] < works[i + 1]) {
            // swap 작업량의 위치
            [works[i], works[i + 1]] = [works[i + 1], works[i]];
            i++;
        }
    }
    
    return works.reduce((acc, work) => acc + Math.pow(work, 2), 0);;
}

// 테스트 1 〉	통과 (0.22ms, 32.9MB)
// 테스트 2 〉	통과 (0.20ms, 33.4MB)
// 테스트 3 〉	통과 (0.10ms, 32.9MB)
// 테스트 4 〉	통과 (0.23ms, 33.4MB)
// 테스트 5 〉	통과 (0.16ms, 33.4MB)
// 테스트 6 〉	통과 (0.17ms, 33.4MB)
// 테스트 7 〉	통과 (0.17ms, 33.4MB)
// 테스트 8 〉	통과 (0.99ms, 33.9MB)
// 테스트 9 〉	통과 (24.76ms, 37.5MB)
// 테스트 10 〉	통과 (0.21ms, 33.3MB)
// 테스트 11 〉	통과 (0.11ms, 33.5MB)
// 테스트 12 〉	통과 (0.22ms, 33.4MB)
// 테스트 13 〉	통과 (0.07ms, 33.4MB)
// 효율성  테스트
// 테스트 1 〉	통과 (815.04ms, 36.8MB)
// 테스트 2 〉	통과 (359.59ms, 36.9MB)
// 채점 결과
// 정확성: 86.7
// 효율성: 13.3
// 합계: 100.0 / 100.0
